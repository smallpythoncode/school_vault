# TAKE 1

Lexical analysis
- computer reads what's on screen to see if it has an identifier or is unknown

This is done via state transition diagram
- id, int, and unknown are final states to classify a token
	-  a class of lexeme
- looking for tokens

## parser
goals
- find syntax errors
- produce the parse tree

### categories
Top down
- begins at the root
- order is that of leftmost derivation

bottom up
- begins at the leaves
- order is that of the reverse of a rightmost derivation

Useful parsers only look one token ahead

13:00
- I am not understanding why I should care about any of this

14:00
- apparently we are analyzing for token
- still not understanding based of her lecture
- if this continues, we might just skip a lot of her future lectures in favor of internet and reading the textbook

`PU @ 25:00`

# TAKE 2

Lexical analysis reads code of program to determine tokens/lexemes
- character by character

Lookup table will try to determine what token an unknown belongs to

## Syntax analyzer (Parser)
- higher than scanner (lexical analyzer)
- uses context free-grammar

### goals
- find all syntax errors
	- attempts to recover quickly
- produce the parse tree, or at least the trace of one

### categories of parsers
Top Down
- beginning at the root
- order is that of a leftmost derivation
- traces or builds the parse tree in preorder

Bottom Up
- begins at the leaves
- orders is that of the reverse of a rightmost derivation

Useful parsers look only one token ahead of the input

`what are terminals/non-terminals`
https://www.geeksforgeeks.org/introduction-to-grammar-in-theory-of-computation/
terminals
- symbols which are the components of the sentences generated using a grammar and are represented using small case letter (a, b, c, etc.)
Non-terminals
- Symbols which take part in the generation of the sentence but are not the component of the sentence
- A, B, C, etc.

https://girfahelp.blogspot.com/2016/04/difference-between-terminal-and-non.html


### The Parsing Problem
Notational conventions
- Oh fuck

"Sigma" - set of alphabet
Terminal symbols
- lowercase letters at the beginning of sigma
Non-terminals
- upper case letters at the beg. of sigma
Terminals or Nonterminals
- Uppercase at the end of sigma
Strings of terminals
- lowercase letters at the end of the alphabet
Mixed strings (terminals and/or nonterminals)
- lowercase Greek letters
- used in sentential form (Ch 3, syntax # 9)

#### Top Down parser
- traces a parse tree in preorder, leftmost derivation

Common TD-parsing algos.: LL algos.
- recursive descent parser
	-  a coded implementation based on BNF
- LL parsers (left to right, leftmost)
	- read the symbol left-to-right; derive from the leftmost var.
	- table-driven implementation - us a parsing table

#### Bottom up parser
- constructs parse tree beginning @ the leaves and progresses towards the roots
- reverse of the rightmost derivation
	- the sentential forms of the derivation are produced in order of last to first

!! Look at slides !!

#### Complexity of parsing
- Parsers that work for any unambiguous grammar are complex and inefficient
	- CSCI 435 - CYK algo.
- Compilers use parser that only work for a subset of all unambiguous grammars, but do it linear time O(n), where n is the length of the input
	- faster algo. but less general

## Recursive descent parsing
Top down parser
- a coded implementation based on BNF
- consists of a collection of subprograms and produces a parse tree in top down order
	- many subprograms are recursive
	- a subprogram for each nonterminal in the grammar, which can parse sentences that can be generated by that nonterminal
- EBNF is ideally suited for being the basis for a recursive-descent parser, because EBNF minimizes the number of nonterminals

### example
```
<expr> --> <term> {+ | -} <term>}
<term> --> <factor> {(* | /) <factor>}
<factor> --> id | int_constant | (<expr>)
```

!! look at slides and [terminals vs non-terminals](obsidian://open?vault=vault_fall24&file=csci365%2Fresources%2Fterminals_non-terminals) !! for understanding

## Limitation/Restriction
- LL Grammar class
	- The left recursion problem: 






